Project: assignment (Next.js + MongoDB quiz manager)

Overview
--------
This project is a Next.js (App Router) + React application for creating, editing, publishing, and listing quizzes backed by MongoDB. It has a simple admin UI (create/edit quizzes), API endpoints that persist quizzes to a `quiz` collection, and client components to manage quizzes (QuizForm, QuizTable).

Quick start
-----------
- Install dependencies: `pnpm install`
- Run dev server: `pnpm dev`
- Build for production: `pnpm build`

Important files & folders
-------------------------
- app/
  - api/quiz/route.ts  -> POST to create a quiz
  - api/quiz/[id]/route.ts -> GET and PUT for a single quiz
  - admin/            -> admin pages for listing, creating, editing quizzes
- components/forms/QuizForm.tsx -> client-side quiz editor and saver
- components/QuizTable.tsx -> admin table listing quizzes with publish action
- lib/mongoClient.ts -> MongoDB connection helper
- lib/authOptions.ts -> next-auth options (used where auth is needed)

Database / id flow
------------------
- Creation: When a quiz is created the POST handler in `app/api/quiz/route.ts` calls `collection.insertOne(doc)`. MongoDB creates an `_id` field (an ObjectId) for the document.
  - Example (simplified):

```ts
const result = await collection.insertOne(doc);
// result.insertedId is the ObjectId generated by MongoDB
return NextResponse.json({ insertedId: result.insertedId.toString() }, { status: 201 });
```

- Client usage: The client receives the inserted id (string). Components use that string in URLs such as `/admin/edit/<id>` and in API calls to `/api/quiz/<id>`.

- Lookup: The dynamic API route `app/api/quiz/[id]/route.ts` reads the path param string and converts it back to a MongoDB ObjectId for queries:

```ts
import { ObjectId } from 'mongodb';
const { id } = await context.params; // string from URL
const quiz = await db.collection('quiz').findOne({ _id: new ObjectId(id) });
```

This is the standard flow: Mongo generates ObjectId, server returns it as string, client uses string in route paths, server converts string back with `new ObjectId(id)` for DB operations.

API endpoints
-------------
- POST `/api/quiz` (app/api/quiz/route.ts)
  - Validates payload (ensures `questions` array exists)
  - Constructs `doc = { title, questions, createdAt }`
  - Inserts with `insertOne(doc)` and returns `insertedId` (string)

- GET `/api/quiz/:id` (app/api/quiz/[id]/route.ts)
  - Reads `id` from `context.params`
  - Uses `new ObjectId(id)` to find the quiz
  - Returns quiz JSON or 404 if not found

- PUT `/api/quiz/:id` (app/api/quiz/[id]/route.ts)
  - Reads `id`, reads JSON body, calls `updateOne({ _id: new ObjectId(id) }, { $set: { ... }})`
  - Returns success JSON

- Publish route (used by QuizTable)
  - There is an endpoint like `/api/quiz/publish` which accepts `{ id, publish }` and updates a `published` boolean for the quiz.

Key client components
---------------------
1) `components/forms/QuizForm.tsx`
- Purpose: Create or edit a quiz in the admin UI.
- Behavior summary:
  - Accepts `initialData` and optional `quizId` (when editing).
  - Maintains local state for `title`, `questions` (array), `currentIndex`.
  - `saveQuiz()` sends a `POST` (create) or `PUT` (update) to the API with JSON body containing `title` and `questions`.
  - After successful save it redirects to `/admin` using Next's `useRouter().push('/admin')`.

- Relevant snippet:
```tsx
const saveQuiz = async () => {
  const quizData = { title, questions };
  const res = await fetch(quizId ? `/api/quiz/${quizId}` : '/api/quiz', {
    method: quizId ? 'PUT' : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(quizData),
  });
  if (!res.ok) throw new Error('Failed to save quiz');
  router.push('/admin');
}
```

2) `components/QuizTable.tsx`
- Purpose: Display a table of quizzes in admin UI, with actions such as Edit and Publish/Unpublish.
- Each quiz row uses `_id` as the key and build links to `/admin/edit/${q._id}`.

- Publish flow snippet:
```ts
const res = await fetch('/api/quiz/publish', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ id, publish: !currentlyPublished }),
});
const body = await res.json();
setQuizzes(prev => prev.map(q => q._id === id ? { ...q, published: body.published } : q));
```

Pages (App Router)
------------------
- `app/admin/page.tsx` – likely lists quizzes (uses `QuizTable`).
- `app/admin/create/page.tsx` – shows `QuizForm` without `quizId` for creating.
- `app/admin/edit/[id]/page.tsx` – fetches quiz data client-side and renders `QuizForm` with `initialData` and `quizId`.

Server / DB helper
------------------
- `lib/mongoClient.ts` handles connecting to MongoDB and exporting a `clientPromise`.
  - The API routes call `const client = await clientPromise; const db = client.db();` then operate on `db.collection('quiz')`.

Notes, pitfalls and gotchas
--------------------------
- Always convert path id strings into `ObjectId` when querying MongoDB.
  - Use: `new ObjectId(id)` and guard for invalid ids if user input could be malformed.

- When returning created ids from the server, convert them to strings, because `ObjectId` objects don't serialize as plain strings by default in JSON responses.
  - Example: `result.insertedId.toString()`.

- Client routing: `useRouter().push('/admin')` should be used from client components (`"use client"`). Ensure redirect runs only after a successful save.

- TypeScript: watch out for accidental Markdown fences or duplicated content inside TSX files; that can break the TypeScript server (seen earlier in this repo repairs).

How id is created and used (summary)
-----------------------------------
1) On create: MongoDB generates `_id: ObjectId(...)` when `insertOne` is called.
2) The API returns `insertedId.toString()` to the client.
3) The client stores/uses that string to link to the edit page and to call `/api/quiz/<id>`.
4) On server operations that query by id, convert the string back: `new ObjectId(id)`.

Example request flows
---------------------
- Create quiz (client):
```js
fetch('/api/quiz', { method: 'POST', body: JSON.stringify({ title, questions }), headers: {'Content-Type':'application/json'} })
  .then(res => res.json())
  .then(body => console.log('created id', body.insertedId));
```

- Edit quiz (client):
```js
fetch(`/api/quiz/${quizId}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ title, questions }) })
```

- Server GET quiz:
```ts
export async function GET(req: Request, context: { params: Promise<{ id: string }> }) {
  const { id } = await context.params;
  const quiz = await db.collection('quiz').findOne({ _id: new ObjectId(id) });
  return NextResponse.json(quiz);
}
```

Recommendations / next tasks
----------------------------
- Add server-side validation of quiz shape for both POST and PUT routes.
- Add error handling for invalid ObjectId strings to return 400 instead of 500.
- Normalize returned API fields: return `id` instead of `_id` in client-facing responses (or include both), so clients rely on `id` consistently.
- Add tests for API contract (create -> read -> update -> delete).

Where I saved this file
-----------------------
- Project root: [ai.txt](ai.txt)

If you want any section expanded (example: full contents of `mongoClient.ts`, `route.ts`, or `QuizForm.tsx` pasted verbatim into this file), tell me which file(s) and I will include them in `ai.txt` as well.